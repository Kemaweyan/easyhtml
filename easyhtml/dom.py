from abc import ABCMeta, abstractproperty, abstractmethod
from html.entities import name2codepoint
import textwrap
import itertools
import re

__all__ = (
    'HTMLTag', 'HTMLDocument', 'PlainText',
    'NumEntity', 'NamedEntity', 'HTMLComment',
)


class HTMLElement(metaclass=ABCMeta):

    # returns a raw HTML code of an element
    @abstractproperty
    def raw_html(self): pass

    # returns a visible string of an element
    @abstractmethod
    def __str__(self): pass


class HTMLSimpleElement(HTMLElement):

    """
    A base class for simple HTML elements.

    """
    def __init__(self, raw_html, data):

        """
        :raw_html: a raw HTML code of the object, type str
        :data: a text that would be returned by __str__, type str

        """
        self._raw_html = raw_html
        self.data = data

    @property
    def raw_html(self):

        """
        Returns a raw HTML code of the object.

        """
        return self._raw_html

    def __str__(self):

        """
        Returns contained text of the object.

        """
        return self.data


# a base class for all elemenets that
# should be contained by TextNode objects
class HTMLText(HTMLSimpleElement):
    pass


class PlainText(HTMLText):

    """
    A plain text object - any string without
    special characters in the document.

    """
    def __init__(self, text):

        """
        :text: a text of the element, type str

        """
        # replace sequenses of space symbols
        # with single spaces (as it looks in web browsers)
        data = re.sub('\s+', ' ', text)
        HTMLText.__init__(self, text, data)


class NamedEntity(HTMLText):

    """
    A class for named HTML entities such as &NAME;

    """
    def __init__(self, name):

        """
        :name: a name of the entity, type str

        """
        # in raw HTML add special characters
        # to the name of entity
        raw_html = '&' + name + ';'
        # get a code of the entity and convert
        # it into utf-8 character
        data = chr(name2codepoint[name])
        HTMLText.__init__(self, raw_html, data)


class NumEntity(HTMLText):

    """
    A class for numeric HTML entities such as &NUMBER;

    """
    def __init__(self, num):

        """
        :num: a numeric code of the entity, type str

        """
        # in raw HTML add special characters
        # to the name of entity
        raw_html = '&#' + num + ';'
        # numeric code could be written in decimal or in hexadecimal formats
        # if it starts on 'x' character then convert it witout first symbol
        # using base 16, otherwise use simple decimal conversion
        data = chr(int(num[1:], 16)) if num.startswith('x') else chr(int(num))
        HTMLText.__init__(self, raw_html, data)


class HTMLHiddenElement(HTMLSimpleElement):

    """
    A base class for hidden HTML elements that are not visible
    on the page such as comments of doctype declaration.

    """
    def __init__(self, raw_html):

        """
        :raw_html: a raw HTML code of the element, type str

        """
        # visible text data is empty
        HTMLSimpleElement.__init__(self, raw_html, '')

    @property
    def raw_html(self):

        """
        Returns a raw HTML code of the comment.

        """
        # add a newline symbol to raw HTML
        # to make a code of following element
        # to start at a new line
        return HTMLSimpleElement.raw_html.fget(self) + '\n'


class HTMLComment(HTMLHiddenElement):

    """
    A class for HTML comments such as <!-- Comment -->

    """
    def __init__(self, text):

        """
        :text: a text of the comment, type str

        """
        # in raw HTML add special characters
        # to the text of comment
        raw_html = '<!-- ' + text + ' -->'
        HTMLHiddenElement.__init__(self, raw_html)


class DoctypeDeclaration(HTMLHiddenElement):

    """
    A class for DOCTYPE declarations such as <!DOCTYPE ...>

    """
    def __init__(self, decl):

        """
        :decl: a text of the declaration, type str

        """
        # in raw HTML add special characters
        # to the text of comment
        raw_html = '<!' + decl + '>'
        HTMLHiddenElement.__init__(self, raw_html)


class HTMLElementMixin(HTMLElement):

    def __str__(self):

        """
        A text of the container consists of text of all
        contained elements.

        """
        # Join together all strings of elements returned by lambda
        # and contained in a sequence generated by map generator
        return ''.join(map(lambda e: str(e), self.elements))

    @property
    def raw_html(self):

        """
        Returns HTML codes of contained elements.

        """
        # join together all raw HTMLs returned by lambda
        # and contained in a sequence generated by map generator
        return ''.join(map(lambda e: e.raw_html, self.elements))


class HTMLContainer(metaclass=ABCMeta):

    """
    A base class for all HTML containers - objects that could contain
    other objects.

    """
    def __init__(self):
        # a list of contained elements
        self.elements = []


class TextNode(HTMLElementMixin, HTMLContainer):

    """
    A container for HTMLText elements.

    """
    @property
    def raw_html(self):

        """
        Returns a raw HTML code of the TextNode that
        consists of HTML codes of all contained elements.

        """
        # join together all raw HTMLs returned by lambda
        # and contained in a sequence generated by map generator
        text = HTMLElementMixin.raw_html.fget(self)
        # add a newline symbol to raw HTML
        # to make a code of following element
        # to start at a new line
        return text + ('\n' if not text.endswith('\n') else '')

    def append(self, element):

        """
        Appends an element to the container.

        :element: an element to add, type HTMLText

        """
        self.elements.append(element)


class TagContainer(HTMLContainer):

    """
    A container that contains HTML tags.

    """
    def __getattr__(self, name):

        """
        An attribute of the object returns
        a collection of all tags with specified name.

        :name: a name of tags, type str

        It's just a "syntax sugar" that makes calls
        more useful:

        object.get_tags_by_name('tag') = object.tag

        """
        # call a method that implements this feature
        return self.get_tags_by_name(name)

    # returns a collection of tags with specified name
    @abstractmethod
    def get_tags_by_name(self, name): pass

    # returns a collection of tags with attributes,
    # specified in the query
    @abstractmethod
    def get_children(self, query): pass

    # returns a tag with specified ID
    @abstractmethod
    def get_element_by_id(self, e_id): pass


class ElementTagContainer(HTMLElementMixin, TagContainer):

    @property
    def inner_html(self):

        """
        Returns HTML codes of contained elements.

        """
        # join together all raw HTMLs returned by lambda
        # and contained in a sequence generated by map generator
        return HTMLElementMixin.raw_html.fget(self)

    @property
    def tags(self):

        """
        Returns a generator of tags contained by the object.

        """
        # filters all elements and yields HTMLTag objects only
        return filter(lambda e: isinstance(e, HTMLTag), self.elements)

    def get_all_tags(self):

        """
        Returns a generator that recursively yields all nested tags.

        """
        tags = self.tags  # tags of THIS object
        # recursively add to the result all
        # children tags including their children
        for tag in self.tags:
            tags = itertools.chain(tags, tag.get_all_tags())
        return tags

    def append(self, element):

        """
        Appends an element to the container.

        :element: an element to add, type HTMLObject

        """
        if isinstance(element, HTMLText):
            # HTMLText objects shold be added
            # to TextNode object
            if not self.elements or \
               not isinstance(self.elements[-1], TextNode):
                # if the last added element is not
                # a TextNode - create it
                self.elements.append(TextNode())
            # add an HTMLText object to the last element
            self.elements[-1].append(element)
        else:
            # another objects just append to the list
            self.elements.append(element)

    def get_tags_by_name(self, name):

        """
        Returns an HTMLCollection object contains tags
        with specified name including nested tags.

        :name: a name of search tags, type str

        """
        # filter tags by name
        return HTMLCollection(filter(lambda e: e.tag_name == name,
                              self.get_all_tags()))

    def get_children(self, query):

        """
        Returns an HTMLCollection object contains tags
        with specified in the query attributes.

        :query: a query to search tags by attributes, type str

        A query should have following format:

        attr1=value1; attr2=value2; attr3=value3 ...

        Returned collection would contain tags that match
        query properly, i.e. have all specified attributes
        and their values equal to ones from the query.

        """
        # use HTMLTag.check_attrs method to check a tag
        # for matching to the query
        return HTMLCollection(filter(lambda e: e.check_attrs(query),
                              self.get_all_tags()))

    def get_element_by_id(self, e_id):

        """
        Returns a tag with specified id. If the tag
        is not found returns None.

        :e_id: an ID of the tag, type str

        """
        # assume that ID is unique and there is
        # one tag with such ID only
        for tag in self.get_all_tags():
            if tag.check_attr('id', e_id):
                return tag
        return None

    # indicates whether a tag is single
    # i.e. does not requre an end tag
    @abstractproperty
    def single(self): pass


class HTMLDocument(ElementTagContainer):

    """
    A root document object. Contains all HTML
    elements and provides an API to access them.

    """
    def __init__(self):
        ElementTagContainer.__init__(self)
        self._doctype = None

    @property
    def single(self):

        """
        A property that indicates whether the tag is
        single, i.e. does not require an endtag.

        Single tags such as <br>, <img>, <input> etc.
        could not contain other elements.

        An HTML document is pseudo-tag that could contain
        other elements, so it is not "single".

        """
        return False

    @property
    def raw_html(self):

        """
        Returns a raw HTML code of an HTML document.

        """
        # raw_html contains a doctype declaration if it exists
        # and inner HTML
        decl = ''
        if self.doctype:
            decl = self.doctype.raw_html
        return decl + self.inner_html

    @property
    def doctype(self):

        """
        Returns a DoctypeDeclaration object.

        """
        return self._doctype

    @doctype.setter
    def doctype(self, decl):

        """
        Sets a DoctypeDeclaration object.

        """
        self._doctype = decl


class HTMLTag(ElementTagContainer):

    """
    An HTML tag object.

    """
    # a list of single tags -
    # they do not require an endtag
    single_tags = (
        'area', 'base', 'basefont', 'bgsound', 'br', 'col',
        'command', 'embed', 'hr', 'img', 'input', 'isindex',
        'keygen', 'link', 'meta', 'param', 'source', 'track',
        'wbr',
    )

    def __init__(self, name, attrs):

        """
        :name: a name of the tag, type str
        :attrs: a tag's attributes, type a list of tuples:

        [(attr1, value1), (attr2: value2)]

        """
        ElementTagContainer.__init__(self)
        self.tag_name = name
        # create a dictionary of attributes
        self.attrs = {k: v for k, v in attrs}

    @property
    def single(self):

        """
        A property that indicates whether the tag is
        single, i.e. does not require an endtag.

        Returns True if tag's name is in the list
        of single tags.

        """
        return self.tag_name in self.single_tags

    @property
    def start_tag(self):

        """
        Returns start tag with all attributes

        """
        # begins with <tag_name
        text = '<' + self.tag_name
        # then append all attributes
        for attr, value in self.attrs.items():
            text += ' {}="{}"'.format(attr, value)
        # and close > with a newline symbol
        text += '>\n'
        return text

    @property
    def end_tag(self):

        """
        Returns end tag

        """
        # end tag could not contain attributes
        return '</' + self.tag_name + '>\n'

    @property
    def raw_html(self):

        """
        Returns a raw HTML code of the tag.

        """
        # all tags have a start tag
        text = self.start_tag
        # single tags don't have a body
        # and an end tag
        if not self.single:
            # for full tags add contained HTML code
            # with an indent of 4 spaces to make a code
            # more readable:
            # <tag>
            #     <tag2>
            #         content...
            #     </tag2>
            # </tag>
            text += textwrap.indent(self.inner_html, ' '*4)
            # and an end tag
            text += self.end_tag
        return text

    def get_attributes(self):

        """
        Returns a dictionary with attributes of the tag

        """
        return self.attrs

    def get_attr(self, name):

        """
        Returns a value of attribut with specified name,
        If the attribute not found - returns None.

        :name: a name of attribute, type str

        """
        return self.attrs.get(name)

    def check_attr(self, name, value):

        """
        Returns True if the tag has an attribute
        with specified name and value.

        """
        # get an attribute
        attr = self.get_attr(name)
        if attr and name == 'class':
            # a "class" attribute could be a list
            # of css classes separated by spaces
            # return True if specifed class value
            # is present in that list
            return value in attr.split(' ')
        # check value
        return attr == value

    def check_attrs(self, query):

        """
        Returns True if attributes of the tag match
        specified query.

        :query: a query to check attributes of the tag, type str

        A query should have following format:

        attr1=value1; attr2=value2; attr3=value3 ...

        """
        # split query to conditions and make a list of tuples
        # with the name and the value of each attribute in the query
        # attributes could be separated by ; with several spaces, so
        # strip spaces before splitting a query component into name and value
        attrs = list(map(lambda item: tuple(item.strip(' ').split('=')),
                     query.split(';')))
        # tuples would be passed to HTMLTag.check_attr method
        # as separate arguments
        # check all attributes and return True only if those all match
        return all(map(lambda a: self.check_attr(*a), attrs))

    def filter_tags_by_attrs(self, query):

        """
        Returns the tag if its attributes match
        specified query. Otherwise returns None

        :query: a query to check attributes of the tag, type str

        A query should have following format:

        attr1=value1; attr2=value2; attr3=value3 ...

        It's used by HTMLCollection to filter elements by queries.

        """
        if self.check_attrs(query):
            return self
        return None


class HTMLCollection(TagContainer):

    """
    A result object returned by get_* methods.
    Collection is an object that contains found
    tags or collections of tags.

    Search in a tag (or in a document) returns
    a collection that contains found tags.

    Search in a collection returns a new collection
    of collections and each of them would contain
    found tags. And so on.

    For instance, the document contains following code:

    <div id="div1">
        <p id="p1"></p>
    </div>
    <div id="div2">
        <p id="p2"></p>
        <p id="p3"></p>
    </div>

    then a call document.get_tags_by_name('div')
    returns a collection with two tags:

    Collection {
        <div id="div1">
        <div id="div2">
    }

    Then call collection.get_tags_by_name('p')
    returns a collection that contains two collections
    with <p> tags in each one.

    Collection {
        Collection {
            <p id="p1">
        }
        Collection {
            <p id="p2">
            <p id="p3">
        }
    }

    HTMLCollection objects are iterable.

    """
    def __init__(self, items):

        """
        :items: items to insert into collection, type iterable

        """
        TagContainer.__init__(self)
        # save items as a list
        self.elements = list(items)

    def __iter__(self):
        self._index = 0
        return self

    def __next__(self):
        try:
            # return current element while
            # it is present
            return self.elements[self._index]
        except:
            # stop iteration when there is
            # no element with such index
            raise StopIteration
        finally:
            # finally increase an index
            # (get the next element in the
            # next iteration)
            self._index += 1

    def __len__(self):

        """
        Returns a count of objects in the collection

        """
        return len(self.elements)

    def _map_elements(self, func):

        """
        Applies a function to each element and
        returns a generator of results.

        :func: a function to filter elements, type callable

        A function shold get one argument (each element)
        end return an HTMLCollection with filtered elements.

        """
        return map(func, self.elements)

    def _get_collection(self, func):

        """
        Creates a new collection of another collection that contains elements
        filtered by func.

        :func: a function to filter elements, type callable

        A function shold get one argument (each element) and return
        an HTMLCollection with filtered elements.

        """
        # apply a function to each element of the collection,
        # results also are collections. Then create a new
        # colletion with these collections and return that
        return HTMLCollection(self._map_elements(func))

    def get_tags_by_name(self, name):

        """
        Search tags with specified name in contained elements and returns
        them as a collection.

        :name: a name of tags, type str

        """
        # creates a collection using get_tags_by_name method.
        return self._get_collection(lambda e: e.get_tags_by_name(name))

    def get_children(self, query):

        """
        Search tags that mutch specified query in contained elements and
        returns them as a collection.

        :query: a query to check attributes of the tag, type str

        A query should have following format:

        attr1=value1; attr2=value2; attr3=value3 ...

        """
        # creates a collection using get_children method.
        return self._get_collection(lambda e: e.get_children(query))

    def get_element(self, index):

        """
        Returns an element with specified index

        :index: an index of the element, type int

        """
        return self.elements[index]

    def __call__(self, query):

        """
        A call to the HTML Collection object
        is the same as filter_tags_by_attrs method.

        :query: a query to check attributes of the tag, type str

        A query should have following format:

        attr1=value1; attr2=value2; attr3=value3 ...

        It's just a "syntax sugar" since a call

        object.tag('attr1=value1; attr2=value2')

        is more useful than

        collection = object.get_tags_by_name('tag')
        collection.filter_tags_by_attrs('attr1=value1; attr2=value2')

        """
        return self.filter_tags_by_attrs(query)

    def __getitem__(self, index):

        """
        Returns an element with specified index

        :index: an index of the element, type int

        It's just a "syntax sugar" that makes calls
        more useful:

        collection[i] = collection.get_element(i)

        """
        return self.get_element(index)

    def filter_tags_by_attrs(self, query):

        """
        Returns a collection that contains elements or
        collections with elements that match specified query.

        A query should have following format:

        attr1=value1; attr2=value2; attr3=value3 ...

        """
        # call filter_tags_by_attrs for each element and filter
        # results removing ones that are empty
        # (None is returned by tags that do not match query)
        return HTMLCollection(filter(lambda t: t is not None,
                              self._map_elements(
                                lambda e: e.filter_tags_by_attrs(query))
                                ))

    def get_element_by_id(self, e_id):

        """
        Returns a tag with specified id. If the tag
        is not found returns None.

        :e_id: an ID of the tag, type str

        """
        # assume that ID is unique and there is
        # one tag with such ID only
        # recursively search in all elements
        for element in self.elements:
            if isinstance(element, HTMLTag):
                # for tags only
                # check ID of the tag first
                if element.get_attr('id') == e_id:
                    return element
            # then search in its content
            tag = element.get_element_by_id(e_id)
            if tag:
                return tag
        return None
